# Configuration file for IRL-Subtitals
version = "2.1";

#Raw audio parameters
raw: {
    fS = 24000;     #Your sample rate
    hopSize = 128;  #Std hop size, can be adjusted
    nBits = 16;     #Bit depth
    nChannels = 4;  # Num of mics

    interface: {
        type = "socket";
        ip = "0.0.0.0";     #Listen on all interfaces
        port = 1001;
    }
}

# Mapping
mapping:
{
    map: (1, 2, 3, 4);
}

# General
general:
{
       
    epsilon = 1E-20;

    # Sample rate parameters
    size: 
    {
        #mu = 24000;     # This should match your raw.fS value
        frameSize = 256;    # Typically 2x hopSize
        hopSize = 128;
    };

    # Sample rate parameters  
    samplerate:
    {
        mu = 24000;     # This should match your raw.fS value Defult 1600
        sigma2 = 0.01;
    };

    #speed of sound parameters
    speedofsound:
    {
        mu = 343.0;     #Speed of sound in m/s
        sigma2 = 25.0;
    };

    #Microphone array configuration
    mics = (

        #Microphone 1 (0.075, 0.075, 0)
        {
            mu = ( +0.075, -0.075, +0.000 );
            sigma2 = (0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000);
            direction = (+0.000, +0.000, +1.000); #Facing up
            angle = (80.0, 100.0);
        },

        #Microphone 2 (0.075, -0.075, 0)
        {
            mu = ( -0.075, -0.075, +0.000 );
            sigma2 = (0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000);
            direction = (+0.000, +0.000, +1.000); #Facing up
            angle = (80.0, 100.0);
        },

        #Microphone 3 (-0.075, -0.075, 0)
        {
            mu = ( +0.075, +0.075, +0.000 );
            sigma2 = (0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000);
            direction = (+0.000, +0.000, +1.000); #Facing up
            angle = (80.0, 100.0);
        },

        #Microphone 4 (-0.075, +0.075, 0)
        {
            mu = ( -0.075, +0.075, +0.000 );
            sigma2 = (0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000);
            direction = (+0.000, +0.000, +1.000); #Facing up
            angle = (80.0, 100.0);
        }
    );

    # Spatial filters to include only a range of direction if required
    # (may be useful to remove false detections from the floor, or
    # limit the space search to a restricted region)
    # Added spatial filters
    spatialfilters = (
        {
            direction = ( 0.0, 0.0, 1.0 );
            angle = (80.0, 100.0);
        }
    );

    # directional scanning parameters
    nThetas = 181;    # Number of azimuths to scan
    nPhis = 91;       # Number of elevations to scan

    # gain parameters
    gainMin = 0.1; # Defualt 0.25
    #gainMax = 10.0;
};

# Noise likelihood (NL)
nl:
{
    deltaL = 30.0;    # Threshold to assign source as noise
    alphaL = 0.1;     # Adaptation rate
}

# Noise Reduction (NR)
nr:
{
    gamma = 0.3;      # Gamma factor to control noise reduction level
    alphaZ = 0.0;     # Adaptation rate for noise floor
}

# Stationary Noise Estimation (SNE)
sne:
{
    b = 3;            # Number of neighboring frames
    alphaS = 0.1;     # Adaptation rate for stationary noise
    L = 50;          # Number of frames to estimate stationary noise defualt 150
    delta = 3.0;      # Detection threshold
    alphaD = 0.1;     # Adaptation rate for noise presence probability
};

# Sound source localization parameters
ssl:
{

    nPots = 4;  # number of potential sources
    nMatches = 10;
    probMin = 0.5; # was 0.3
    nRefinedLevels = 1;
    interpRate = 4; # was 1

    # Search resolution configuration
    # Number of scans: level is the resolution of the sphere
    # and delta is the size of the maximum sliding window
    # (delta = -1 means the size is automatically computed)
    scans = (
        { level = 2; delta = -1; },
        { level = 4; delta = -1; }
    );

   # Output to export potential sources
    potential: {

        format = "json";
        # format = "undefined"

        interface: {
            # type = "terminal";
            # type = "blackhole"
            type = "file";
            path = "potential.txt";

        };

    };

    # # Output to export potential sources
    # potential: {

    #     # format = "undefined";
    #     format = "json";

    #     interface: {
    #         # type = "blackhole";
    #         type = "socket"; ip = "127.0.0.1"; port = 9001;
    #     };
    # };

};

sinks: {
   # Output to export potential sources
    potential: {

        format = "json";
        # format = "undefined"

        interface: {
            # type = "terminal";
            # type = "blackhole"
            type = "file";
            path = "potential.txt";
        };

    };

    # Output to export tracked sources
    tracked: {

        format = "json";

        interface: {
            # type = "terminal";
            type = "file";
            path = "tracks.txt";
	};
    };
}

# Sound Source Tracking
sst:
{  
    # Mode is either "kalman" or "particle"
    mode = "kalman";

    # Add is either "static" or "dynamic"
    add = "dynamic";

    # Parameters used by both the Kalman and particle filter
    active = (
        { weight = 1.0; mu = 0.3; sigma2 = 0.0025 }
    );

    inactive = (
        { weight = 1.0; mu = 0.15; sigma2 = 0.0025 }
    );

    sigmaR2_prob = 0.0025;
    sigmaR2_active = 0.0225;
    sigmaR2_target = 0.0025;
    Pfalse = 0.1;
    Pnew = 0.1;
    Ptrack = 0.8;

    theta_new = 0.9;
    N_prob = 5;
    theta_prob = 0.8;
    N_inactive = ( 150, 200, 250, 250 ); # default 250, 250, 250, 250
    theta_inactive = 0.9;

    # Parameters used by the Kalman filter only
    kalman: {
        sigmaQ = 0.001;
    };
   
    # Parameters used by the particle filter only
    particle: {

        nParticles = 1000;
        st_alpha = 2.0;
        st_beta = 0.04;
        st_ratio = 0.5;
        ve_alpha = 0.05;
        ve_beta = 0.2;
        ve_ratio = 0.3;
        ac_alpha = 0.5;
        ac_beta = 0.2;
        ac_ratio = 0.2;
        Nmin = 0.7;

    };

    # Empty target list (you can add specific targets if needed)
    target: ();

    # Output to export tracked sources
    tracked: {

        format = "json";

        interface: {
            # type = "terminal";
            type = "file";
            path = "tracks.txt";
        };

    };

};

# Sound Source Separation
sss:
{

    # Separation mode is either "dds", "dgss" or "dmvdr"
    # Post-filtering mode is either "ms" or "ss"
    mode_sep = "dds";
    mode_pf = "ms"; 

    gain_sep = 1.0;
    gain_pf = 3.0;

    dds: {
        # Empty configuration for dds
    };

    dgss: {

        mu = 0.01;
        lambda = 0.5;

    };

    dmvdr: {
        # Empty configuration for dmvdr
    };

    ms: {
        alphaPmin = 0.07;
        eta = 0.5;
        alphaZ = 0.8;        
        thetaWin = 0.3;
        alphaWin = 0.3;
        maxAbsenceProb = 0.9;
        Gmin = 0.01;
        winSizeLocal = 3;
        winSizeGlobal = 23;
        winSizeFrame = 256;
    };

    ss: {
        Gmin = 0.01;
        Gmid = 0.9;
        Gslope = 10.0;
    }

    # Configuration for separated audio output
    separated: {

        fS = 22050;
        hopSize = 128;
        nBits = 16;        

        interface: {
            type = "file";
            path = "separated.raw";
            # type = "blackhole";
        };        

    };

    postfiltered: {

        fS = 22050;
        hopSize = 128;
        nBits = 16;        
        gain = 3.0;

        interface: {
            type = "file";
            path = "postfiltered.raw";
            # type = "blackhole";
        };
    } 

};

# Sound Classification
classify:
{

    frameSize = 1024;   # Default 4096
    winSize = 3;        # Default 3
    tauMin = 32;        # Default 88
    tauMax = 200;       # Default 551
    deltaTauMax = 7;    # Default 20
    alpha = 0.3; 
    gamma = 0.05;
    phiMin = 0.15;      # Default 0.5
    r0 = 0.2;    

    category: {

        format = "undefined";

        interface: {
            type = "blackhole";
        }
    }

};
